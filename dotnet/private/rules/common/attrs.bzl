"The attributes used by binary/library/test rules"

load("@bazel_skylib//lib:dicts.bzl", "dicts")
load("//dotnet/private:providers.bzl", "DotnetAssemblyCompileInfo", "DotnetAssemblyRuntimeInfo")
load("//dotnet/private/sdk/apphost_packs:apphost_pack_transition.bzl", "apphost_pack_transition")
load("//dotnet/private/sdk/runtime_packs:runtime_pack_transition.bzl", "runtime_pack_transition")
load("//dotnet/private/sdk/targeting_packs:targeting_pack_transition.bzl", "targeting_pack_transition")
load("//dotnet/private/transitions:default_transition.bzl", "default_transition")
load("//dotnet/private/transitions:tfm_transition.bzl", "tfm_transition")

# These are attributes that are common across all the binary/library/test .Net rules
COMMON_ATTRS = {
    "deps": attr.label_list(
        doc = "Other libraries, binaries, or imported DLLs",
        providers = [DotnetAssemblyCompileInfo, DotnetAssemblyRuntimeInfo],
        cfg = tfm_transition,
    ),
    "data": attr.label_list(
        doc = "Runtime files. It is recommended to use the @rules_dotnet//tools/runfiles library to read the runtime files.",
        allow_files = True,
        default = [],
        allow_empty = True,
        # We transition to the default configuration because the end user might have dotnet binaries
        # in their data and we want the TFM graphs to be disconnected
        cfg = default_transition,
    ),
    "compile_data": attr.label_list(
        doc = "Additional compile time files.",
        allow_files = True,
        default = [],
        allow_empty = True,
        # We transition to the default configuration because the end user might have dotnet binaries
        # in their compile_data and we want the TFM graphs to be disconnected
        cfg = default_transition,
    ),
    "keyfile": attr.label(
        doc = "The key file used to sign the assembly with a strong name.",
        allow_single_file = True,
        # We transition to the default configuration because the end user might have a keyfile
        # that is generated by a dotnet binary
        cfg = default_transition,
    ),
    "langversion": attr.string(
        doc = "The version string for the language.",
    ),
    "resources": attr.label_list(
        doc = "A list of files to embed in the DLL as resources.",
        allow_files = True,
        # We transition to the default configuration because the end user might have resources
        # that is generated by a dotnet binary
        cfg = default_transition,
    ),
    "out": attr.string(
        doc = "File name, without extension, of the built assembly.",
    ),
    "target_frameworks": attr.string_list(
        doc = "A list of target framework monikers to build" +
              "See https://docs.microsoft.com/en-us/dotnet/standard/frameworks",
        mandatory = True,
        allow_empty = False,
    ),
    "project_sdk": attr.string(
        doc = "The project SDK that is being targeted. " +
              "See https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview",
        default = "default",
        values = ["default", "web"],
    ),
    "defines": attr.string_list(
        doc = "A list of preprocessor directive symbols to define.",
        default = [],
        allow_empty = True,
    ),
    "internals_visible_to": attr.string_list(
        doc = "Other libraries that can see the assembly's internal symbols. Using this rather than the InternalsVisibleTo assembly attribute will improve build caching.",
    ),
    "treat_warnings_as_errors": attr.bool(
        doc = "Treat all compiler warnings as errors. Note that this attribute can not be used in conjunction with warnings_as_errors.",
        mandatory = False,
        default = False,
    ),
    "warnings_as_errors": attr.string_list(
        doc = "List of compiler warning codes that should be considered as errors. Note that this attribute can not be used in conjunction with treat_warning_as_errors.",
        mandatory = False,
        default = [],
    ),
    "warnings_not_as_errors": attr.string_list(
        doc = "List of compiler warning codes that should not be considered as errors. Note that this attribute can only be used in conjunction with treat_warning_as_errors.",
        mandatory = False,
        default = [],
    ),
    "warning_level": attr.int(
        doc = "The warning level that should be used by the compiler.",
        mandatory = False,
        values = [0, 1, 2, 3, 4, 5],
        default = 3,
    ),
    "generate_documentation_file": attr.bool(
        doc = "Whether or not to generate a documentation file.",
        default = True,
    ),
    "compiler_options": attr.string_list(
        doc = "Additional options to pass to the compiler. This attribute should only be used if the compiler flag has not already been exposed as an attribute.",
        mandatory = False,
        default = [],
    ),
    "_target_framework": attr.label(
        default = "//dotnet:target_framework",
    ),
    "_windows_constraint": attr.label(default = "@platforms//os:windows"),
    "_allowlist_function_transition": attr.label(
        default = "@bazel_tools//tools/allowlists/function_transition_allowlist",
    ),
    "_compiler_wrapper_sh": attr.label(
        default = "//dotnet/private:compiler_wrapper.sh",
        executable = True,
        cfg = "exec",
        allow_single_file = True,
    ),
    "_compiler_wrapper_bat": attr.label(
        default = "//dotnet/private:compiler_wrapper.bat",
        executable = True,
        cfg = "exec",
        allow_single_file = True,
    ),
    "_targeting_pack": attr.label(
        default = "//dotnet/private/sdk/targeting_packs:targeting_pack",
        cfg = targeting_pack_transition,
    ),
}

# These are attributes that are common across all libarary rules
LIBRARY_COMMON_ATTRS = {
    "exports": attr.label_list(
        doc = """
        List of targets to add to the dependencies of those that depend on this target. 
        Use this sparingly as it weakens the precision of the build graph.
        
        This attribute does nothing if you don't have strict dependencies enabled.""",
        default = [],
        providers = [DotnetAssemblyCompileInfo, DotnetAssemblyRuntimeInfo],
    ),
}

# These are attributes that are common across all binary/test rules
BINARY_COMMON_ATTRS = {
    "roll_forward_behavior": attr.string(
        doc = "The roll forward behavior that should be used: https://learn.microsoft.com/en-us/dotnet/core/versions/selection#control-roll-forward-behavior",
        default = "Major",
        values = ["Minor", "Major", "LatestPatch", "LatestMinor", "LatestMajor", "Disable"],
    ),
    "winexe": attr.bool(
        doc = "If true, output a winexe-style executable, otherwise" +
              "output a console-style executable.",
        default = False,
    ),
    "appsetting_files": attr.label_list(
        doc = "A list of appsettings files to include in the output directory.",
        allow_files = True,
        default = [],
        allow_empty = True,
        # We transition to the default configuration because the end user might have dotnet binaries
        # in their appsetting_files and we want the TFM graphs to be disconnected
        cfg = default_transition,
    ),
    "_bash_runfiles": attr.label(
        default = "@bazel_tools//tools/bash/runfiles",
        allow_single_file = True,
    ),
    "_launcher_sh": attr.label(
        doc = "A template file for the launcher on Linux/MacOS",
        default = "//dotnet/private:launcher.sh.tpl",
        allow_single_file = True,
    ),
    "_launcher_bat": attr.label(
        doc = "A template file for the launcher on Windows",
        default = "//dotnet/private:launcher.bat.tpl",
        allow_single_file = True,
    ),
    "_apphost_pack": attr.label(
        default = "//dotnet/private/sdk/apphost_packs:apphost_pack",
        cfg = apphost_pack_transition,
    ),
    "_runtime_pack": attr.label(
        default = "//dotnet/private/sdk/runtime_packs:runtime_pack",
        cfg = runtime_pack_transition,
    ),
}

# These are attributes that are common across all the binary/library/test C# rules
CSHARP_COMMON_ATTRS = dicts.add(
    COMMON_ATTRS,
    {
        "srcs": attr.label_list(
            doc = "The source files used in the compilation.",
            allow_files = [".cs"],
            # We transition to the default configuration because the end user might have srcs
            # that is generated by a dotnet binary
            cfg = default_transition,
        ),
        "additionalfiles": attr.label_list(
            doc = "Extra files to configure analyzers.",
            allow_files = True,
            # We transition to the default configuration because the end user might have additional files
            # that is generated by a dotnet binary
            cfg = default_transition,
        ),
        "allow_unsafe_blocks": attr.bool(
            doc = "Allow compiling unsafe code. It true, /unsafe is passed to the compiler.",
            mandatory = False,
            default = False,
        ),
        "nullable": attr.string(
            doc = "Enable nullable context, or nullable warnings.",
            mandatory = False,
            default = "disable",
            values = ["disable", "enable", "warnings", "annotations"],
        ),
        "run_analyzers": attr.bool(
            doc = "Controls whether analyzers run at build time.",
            mandatory = False,
            default = True,
        ),
        "nowarn": attr.string_list(
            doc = "List of warnings that should be ignored",
            mandatory = False,
            default = ["CS1701", "CS1702"],
        ),
    },
)

# These are attributes that are common across all the library C# rules
CSHARP_LIBRARY_COMMON_ATTRS = dicts.add(
    CSHARP_COMMON_ATTRS,
    LIBRARY_COMMON_ATTRS,
)

# These are attributes that are common across all the binary C# rules
CSHARP_BINARY_COMMON_ATTRS = dicts.add(
    CSHARP_COMMON_ATTRS,
    BINARY_COMMON_ATTRS,
)

# These are attributes that are common across all the binary/library/test F# rules
FSHARP_COMMON_ATTRS = dicts.add(
    COMMON_ATTRS,
    {
        "srcs": attr.label_list(
            doc = "The source files used in the compilation.",
            allow_files = [".fs"],
            # We transition to the default configuration because the end user might have srcs
            # that is generated by a dotnet binary
            cfg = default_transition,
        ),
        "nowarn": attr.string_list(
            doc = "List of warnings that should be ignored",
            mandatory = False,
            default = [],
        ),
    },
)

# These are attributes that are common across all the library F# rules
FSHARP_LIBRARY_COMMON_ATTRS = dicts.add(
    FSHARP_COMMON_ATTRS,
    LIBRARY_COMMON_ATTRS,
)

# These are attributes that are common across all the binary F# rules
FSHARP_BINARY_COMMON_ATTRS = dicts.add(
    FSHARP_COMMON_ATTRS,
    BINARY_COMMON_ATTRS,
)
